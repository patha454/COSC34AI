Group Two:

Fleury, S;
Griffin, L;
Paterson, H;
Scarlet, A.

Group Two was tasked to develop a basic AI system to navigate a robot over a checcboard-like tile pattern before locating and moving a weighted tower. We accomplished this by working as a single software team to develop each system of our AI in sequence, leavering our respective strengths to resolve each stage of development quickly. We iterated several, increasingly sophisticated, algorithims for each stage of the task, developing new ones in response to the difficulities we encountered during our ongoing testing. We encountered several difficulities during the task, related to our project management was wells as more concret technical issues.

Our bot divides the task into three distinct phases: First, Advancing along the 'chessboard,' while counting tiles; Second, approaching the tower; Third, moving the tower off the tile it's located on. Intermediate tasks which didn't clearly belong in a particular phase, such as turning right after phase one before we could start phase two, were arbitarily assigned to a phase in our initial design.

In phase one, We used a proactive correction algorithim to navigate the tiles. Our initial algorithims assumed course corrections would not be required because the robot would drive straight. Our testing showed this algorithim caused the bot deviate from the expected straight course and the error accumulation was difficult to corect. The algorithim currently stops after locating each black tile and computes a course correction. Our algorithim computes the correction by multiplying a hardcoded adjustment factor (based on the geometry of the tiles in the test enviroment) with the weighted average of the angle to each side, perpendicular to the direction of movement, of the black tile. Our bot is reset to to its orriginal heading, and the course correction is applied before the bot drives forward searching for the next black tile.

We detect the edges of tiles with by considering the difference of time averages in an independent thread. The task specifications suggested that the lighting conditions in the test enviroment were variable - additionally, the dirt and speckled tiles introduce additional sensor noise. We use the average light-intensity reading over a short period, currently 0.1 seconds, to compensate for the enviromental noise. We realised we could not use absolute or hardcoded values to detect the diffrent tile colours because the detected readings would vary with the ambient lighting. We detect changes in tile colour by monitering the diffrence of the time-averaged readings, relative to a threshold factor. Our algorithim determines colour of the new tile can be determined from the sign of the diffrence: A negitive diffrence indicates the drop in intensity as the bot moves onto a black tile.

Phase two starts assuming the bot is facing aproximatly towards the tower. Initially the algorithim drives forward under dead reckoning, because the tower is outside the maximum range of the ultrasound sonar. The bot enters a search and advance loop when it arrives within sonar range. The bot's search and advance loop searches fourty-five degreese to each side of the robot for sonar returns, orientates the bot toward the minimum sensor reading, and drives a set distance forward. The robot will maintain the search loop until the robot is immediatly in front of the tower, when at least one of the two exit conditions is met: The sonar return is less than a prescribed distance, or a touch sensor is triggered. The bot finally once aligns itself straight with respect to the tower and is ready to commense phase three.

The bot starts phase three assuming the tower is less than two centimeters from the bot in an apromiatly forward direction. The bot reverses brieftly to provide itself with room to acclerate, then moves forward at full power to push the tower off the black tile. The bot uses dead reackoning to determine when the tower has been sufficently moved. Our use of dead reckoning to compute the bot's final moement can lead the bot terminating in an erratic final position, but acceptable considering that the specification how far the tower should be moved were also imprecise. The bot needs to reverse before ramming the tower to accomidate it's accleration: The friction coefficent of an object is higher when it is static than in motion, so the bot needs to reach a higher speed than normal to start the tower moving.

As we developed our algorithims we encountered a number of difficulties that causes us to adjust our code or, in extream cases, switch to using a diffrent algorithim for a particular task. Our examples include the evoltuion of the bot's phase one algorithim in responce to difficulites in the enviroment, unreliable sonar readings in the second phase, occurances of an unrecoverable crash cause by lazily written multi-threaded code, and a misunderstanding of the project specifications. We also encountered project managemet difficulties when our member's timetables proved unaccomidateing to group meetings.

Our initial approach to phase one was to drive the bot forward continously, until the count of tile passed reached a specified value. Our initial code used the same multi-threaded tile counter as our final version. We found the bot tended not to drive straigt, veering off the path of tiles, when we tested the bot with this algorithim. We assume this deviation was caused by a combination of assymetric motor conditions, and slight undulations in the test surface. We were initially uncertain how to correct this behaviour, and tried to move the bot in a zig-zaging course to 'average out' under the law of large numbers. This zig zagging also proved unsucsessful because of the floor slopes. We eventually mocked up the actions of the robot, using a match-box car, so we could simulate the 'though process' of the robot as a group. Our childish approach to brainstorming earned us more than a few odd looks from passerbys in the computer science lobby, but led us to our current algorithim of correcting the bot's course on each black tile. During phase two we encountered a compareable difficulity with an initial algorithim that tried to scan for the tower while the robot was under way. We used to same brainstorming and modeling approach to develop our current algorithim which stops to perform each sonar scan.

We occasionally observed an out-of-range exception being throwen as we tested various unrelated parts of our code. The exception was being throwen in our tile counting thread when two diffrent function attempted to minipulate an listed used to compute average readings from the light sensor. The bug was a classic data race caused by the tile counter therad deleting old values from the list before replacing them with a new one, while another thread computed the average value of this array, occasionally tryning to access an indexed reading that had been deleted bug not yet replaced. As only one member of our group was familiar with multi-threading, the problem was refered to him for a solution: He had initially written the threading code in a hurry, and had forseen the chance of the data race occuring but deemed it too unlickly to research the Python threading API. When we realised that the bug was a practical possibility, he implimented a lock on the shared data structure.

During the final phase of testing, we reviewed the specifications and realised he had misunderstood the position the bot would start in. The bot's algorithims assumed it would start on the first of the fifteen black tiles, facing down the line of tiles. We paniced when we noticed the actual requirement, during one of our final group testing session. We implimented a very naieve algorithim to handel the 'new' starting requirement, because we decided we didn't have time to develop a more sophisticated approach: The bot handels a special case on the first black tile it finds, which turns itself right by ninty degrees and reverses slightly, before continuing with our existing algorithim. 

Finally, we encountered some softer difficulties in our timetables. We would have prefered to approach this project by meeting and working together with a test robot. Our scheduals prevented more than two of us meeting at a time, so we had to find another approach. We realised that only one of us, at any time, would be able to test the robot in the labs and correct bugs. We decided to use our poor schedualing to our advantage and use a 'programming team' model, where we concentrated our respective tallents on the same part of the project until it was finished. Under this system, our strongest Python programmer took responsibility for writing the code, two algorithimists provided theroycrafted the algorithims, and one approver pro-activly reviewed identified possible bugs in the code. We used this system because we did not need to be in the lab at the same time to preform our tasks: The programmer could write and test at his will, the algorithimis could view the test envirment at their leasure, and the reviewer could provide a fresh pair of eyes from anywhere he could access the code. We also were able to develop our bot very quickly and reliably with this approach

Throughout our development of the bot we needed to solve a number of technical and non-technical problems. We were each challanged by our lack of forsight, lazy programming, and personal scheduals. Individually, these challanges would have caused us significant difficulity. Collectily, we were able to pool our abilities and resolve our challanges efficently. Our collebration produced a series of simple, but robust algorithims that allow our robot to complete the task in a reasonable manner.





